import merge from 'merge-options'
import EventEmitter from 'events'

import transports from './transports'
import * as helpers from './helpers'
import * as defaults from './defaults'
import * as formatter from './formatter'

class LoggerNeue extends EventEmitter:
  constructor (options = defaults.OPTIONS) ->
    super()

    if !helpers.isObject(options):
      throw new TypeError('options must be an object')

    this.file = options.file?.path
      ? merge(defaults.FILE, options.file)
      : false

    this.console = merge(defaults.CONSOLE, options.console)
    this.levels = defaults.normalizeLevels(options.levels)

    this.setConsoleLevel(this.console.level)

    for key name, val props in this.levels:
      this.addLevel(name, props)

  static create (options) ->
    new LoggerNeue(options)

  addLevel (name, properties) ->
    if this[name]: return

    now properties = defaults.normalizeDefinition(properties)
    this.levels[name] = properties

    this[name] = (...args) =>
      this.log(name, ...args)

    this[name].format = (template, ...args) =>
      if args.length == 1:
        obj = args[0]
        if obj == Object(obj):
          now args = obj

      this.log(name, formatter.format(template, args))

  log (level, ...args) ->
    let action, number, logged

    if typeof level == 'string':
      if !(level in this.levels):
        throw new Error(
          `no such log level is defined ('${level}')`
        )

      now action = level
      now number = this.levels[level].level
    else:
      res = this.getLevelByNumber(level)
      if !res:
        throw new Error(
          `could not find method name for level ${level}`
        )

      now action = res
      now number = level

    if this.console.level >= number:
      transports.console.call(this, action, formatter, args)
      now logged = true

    if this.file and this.file.level >= number:
      transports.file.call(this, action, formatter, args)
      now logged = true

    if logged:
      props = { name: action, level: number, args }
      this.emit('log', props)
      this.emit(`log:${action}`, props)

  getLevelByNumber (n) ->
    for key name, val v in this.levels:
      if v.level == n: return name

  getNumberOfLevel (name) ->
    Number(this.levels[name]?.level) or 0

  getLevelNames () ->
    Object.keys(this.levels)

  getConsoleLevel () ->
    this.console.level

  setConsoleLevel (level) ->
    if typeof level == 'string':
      this.console.level = this.getNumberOfLevel(level)
    else:
      this.console.level = Number(level) or 0

  getFileLevel () ->
    this.file.level

  setFileLevel (level) ->
    if typeof level == 'string':
      this.file.level = this.getNumberOfLevel(level)
    else:
      this.file.level = Number(level) or 0

export default LoggerNeue
